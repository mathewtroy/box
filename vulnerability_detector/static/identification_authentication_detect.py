import os
import re
from utils.utils import read_file_contents
from report_generators.identification_authentication_report import generate_identification_authentication_report


# Function to analyze a single PHP file for identification and authentication vulnerabilities
def analyze_php_code_for_identification_authentication(content, php_file):
    """
    Analyze PHP content for vulnerabilities related to identification and authentication.

    Args:
        content (str): The PHP file content.
        php_file (str): The name of the PHP file.

    Returns:
        list: A list of identified vulnerabilities in the PHP file.
    """
    vulnerabilities = []

    # Check for missing brute-force protection keywords
    brute_force_protection_found = bool(
        re.search(r'\b(login_attempts|lockout|rate_limit|sleep)\b', content, re.IGNORECASE))

    # Check for missing two-factor authentication keywords
    two_factor_authentication_found = bool(
        re.search(r'\b(two_factor|send_otp|check_2fa|verify_otp)\b', content, re.IGNORECASE))

    # Check for plain text passwords or weak encryption
    plaintext_passwords_found = bool(re.search(r'\$password', content, re.IGNORECASE)) and not re.search(
        r'password_hash|bcrypt', content, re.IGNORECASE)

    # Add issues if certain security mechanisms are missing
    if not brute_force_protection_found:
        vulnerabilities.append({
            'file': php_file,
            'description': 'Missing brute-force protection mechanism.',
            'impact': 'Vulnerable to brute-force attacks.',
            'recommendation': 'Implement account lockout or delay after multiple failed login attempts.'
        })

    if not two_factor_authentication_found:
        vulnerabilities.append({
            'file': php_file,
            'description': 'Missing two-factor authentication.',
            'impact': 'Accounts are vulnerable to unauthorized access with a password alone.',
            'recommendation': 'Implement two-factor authentication for stronger security.'
        })

    if plaintext_passwords_found:
        vulnerabilities.append({
            'file': php_file,
            'description': 'Plain text or weakly hashed passwords detected.',
            'impact': 'Passwords may be exposed in case of a database breach.',
            'recommendation': 'Use strong hashing (e.g., bcrypt) for storing passwords.'
        })

    return vulnerabilities


# Function to scan PHP files for identification and authentication vulnerabilities
def scan_php_files_for_issues(php_dir):
    """
    Scan PHP files in a directory for vulnerabilities.

    Args:
        php_dir (str): The directory containing PHP files.

    Returns:
        tuple: A tuple containing the list of vulnerabilities and scanned files.
    """
    scanned_files = []
    all_vulnerabilities = []

    if not os.path.exists(php_dir):
        print(f"Directory not found: {php_dir}")
        return all_vulnerabilities, scanned_files

    php_files = [
        f for f in os.listdir(php_dir)
        if f.lower().endswith('.php') and re.search(r'login|auth|signin|sign_in', f, re.IGNORECASE)
    ]

    if not php_files:
        print(f"No relevant PHP files found in {php_dir}")
        return all_vulnerabilities, scanned_files

    print("Scanning PHP files for identification and authentication issues:", php_files)
    for php_file in php_files:
        php_path = os.path.join(php_dir, php_file)
        content = read_file_contents(php_path)
        scanned_files.append(php_file)

        if not content:
            print(f"Could not read file: {php_path}")
            continue

        print(f"Scanning file: {php_file}")
        vulnerabilities = analyze_php_code_for_identification_authentication(content, php_file)
        all_vulnerabilities.extend(vulnerabilities)

    return all_vulnerabilities, scanned_files


# Function to run the identification and authentication test
def run_identification_authentication_test():
    """
    Main function to execute the identification and authentication test.
    It scans relevant PHP files and generates a report.
    """
    php_dir = os.path.join('input', 'vulnerable')

    vulnerabilities, scanned_files = scan_php_files_for_issues(php_dir)
    generate_identification_authentication_report(vulnerabilities, scanned_files)

    print("Identification and Authentication Report generated successfully at reports/result_static_php_identification_authentication.txt!\n")
