import os
import re
from report_generators.cryptographic_failures_report import generate_cryptographic_failures_report
from utils.utils import read_file_contents


def scan_php_files_for_cryptographic_issues(php_dir):
    """
    Scan PHP files for cryptographic vulnerabilities, specifically related to password handling.

    Args:
        php_dir (str): Path to the directory containing PHP files.

    Returns:
        tuple: List of vulnerabilities, list of scanned files.
    """
    vulnerabilities = []
    scanned_files = []

    if not os.path.exists(php_dir):
        print(f"Directory not found: {php_dir}")
        return vulnerabilities, scanned_files

    php_files = [f for f in os.listdir(php_dir) if f.lower().endswith('.php')]
    if not php_files:
        print(f"No PHP files found in {php_dir}")
        return vulnerabilities, scanned_files

    print("Scanning PHP files for cryptographic failures:", php_files)
    for php_file in php_files:
        php_path = os.path.join(php_dir, php_file)
        content = read_file_contents(php_path)
        scanned_files.append(php_file)

        if not content:
            print(f"Could not read file: {php_path}")
            continue

        print(f"Scanning file: {php_file}")
        analyze_php_file_for_password_handling(content, php_file, vulnerabilities)

    return vulnerabilities, scanned_files


def analyze_php_file_for_password_handling(content, php_file, vulnerabilities):
    """
    Analyze a PHP file for vulnerabilities related to password handling.

    Args:
        content (str): The PHP file content.
        php_file (str): The name of the PHP file.
        vulnerabilities (list): A list to store detected vulnerabilities.
    """
    contains_password_input = re.search(r'<input\s+[^>]*type=["\']password["\']', content, re.IGNORECASE)

    if contains_password_input:
        password_hash_present = re.search(r"password_hash\s*\(", content, re.IGNORECASE) is not None
        password_verify_present = re.search(r"password_verify\s*\(", content, re.IGNORECASE) is not None
        password_compare_pattern = re.compile(r"if\s*\(\s*\$pass\s*==\s*\$row\['password'\]\s*\)", re.IGNORECASE)

        if password_compare_pattern.search(content) and not password_verify_present:
            vulnerabilities.append({
                'file': php_file,
                'description': 'Passwords are compared in plain text without using password_verify during authentication.',
                'impact': 'Sensitive user passwords are vulnerable to compromise in case of a data breach.',
                'recommendation': 'Use password_verify() function to verify hashed passwords during user authentication.'
            })
            print(f"Detected plaintext password comparison in {php_file}")

        elif not password_hash_present:
            vulnerabilities.append({
                'file': php_file,
                'description': 'Passwords are stored without using password_hash during registration.',
                'impact': 'Passwords might be stored in plain text, making them vulnerable to compromise.',
                'recommendation': 'Use password_hash() function to securely hash passwords before storing them in the database.'
            })
            print(f"Detected missing password_hash in {php_file}")
    else:
        vulnerabilities.append({
            'file': php_file,
            'description': 'This file does not handle passwords or authentication.',
            'impact': 'None',
            'recommendation': 'No actions required for cryptographic security in this file.'
        })


def scan_sql_files_for_plaintext_passwords(sql_dir):
    """
    Scan SQL files for plaintext password storage issues.

    Args:
        sql_dir (str): Path to the directory containing SQL files.

    Returns:
        tuple: Dictionaries containing user data tables and plaintext password records, list of scanned files.
    """
    user_data_tables = {}
    plaintext_passwords = {}
    scanned_files = []

    if not os.path.exists(sql_dir):
        print(f"Directory not found: {sql_dir}")
        return user_data_tables, plaintext_passwords, scanned_files

    sql_files = [f for f in os.listdir(sql_dir) if f.lower().endswith('.sql')]
    if not sql_files:
        print(f"No SQL files found in {sql_dir}")
        return user_data_tables, plaintext_passwords, scanned_files

    for sql_file in sql_files:
        sql_path = os.path.join(sql_dir, sql_file)
        content = read_file_contents(sql_path)
        scanned_files.append(sql_file)

        if not content:
            print(f"Could not read file: {sql_path}")
            continue

        analyze_sql_file_for_plaintext_passwords(content, sql_file, user_data_tables, plaintext_passwords)

    return user_data_tables, plaintext_passwords, scanned_files


def analyze_sql_file_for_plaintext_passwords(content, sql_file, user_data_tables, plaintext_passwords):
    """
    Analyze an SQL file for plaintext password storage issues.

    Args:
        content (str): The SQL file content.
        sql_file (str): The name of the SQL file.
        user_data_tables (dict): Dictionary to store user data from SQL files.
        plaintext_passwords (dict): Dictionary to store plaintext password records.
    """
    insert_pattern = re.compile(r"INSERT\s+INTO\s+`users`\s+\((.*?)\)\s+VALUES\s*(\((.*?)\));",
                                re.IGNORECASE | re.DOTALL)
    matches = insert_pattern.findall(content)
    user_data_tables[sql_file] = []
    plaintext_passwords[sql_file] = []

    if matches:
        for columns, values, _ in matches:
            columns = [col.strip(' `') for col in columns.split(',')]
            records = re.findall(r'\((.*?)\)', values)
            for record in records:
                values_list = [val.strip(" '") for val in record.split(',')]
                user_record = dict(zip(columns, values_list))
                user_data_tables[sql_file].append(user_record)
                password = user_record.get('password', '')

                if not (len(password) == 60 and (password.startswith('$2y$') or password.startswith('$2a$'))):
                    plaintext_passwords[sql_file].append(user_record)

    # Add message if no plaintext passwords are found
    if not plaintext_passwords[sql_file]:
        plaintext_passwords[sql_file] = "No plaintext passwords found."


def run_cryptographic_failures_test():
    """
    Main function to run the cryptographic failures test, scanning both PHP and SQL files.
    """
    php_dir = os.path.join('input', 'vulnerable')
    sql_dir = os.path.join('input', 'db')

    php_vulnerabilities, php_scanned_files = scan_php_files_for_cryptographic_issues(php_dir)
    sql_user_data, sql_plaintext_passwords, sql_scanned_files = scan_sql_files_for_plaintext_passwords(sql_dir)

    # Combine all scanned files
    scanned_files = php_scanned_files + sql_scanned_files

    # Generate the cryptographic failures report
    generate_cryptographic_failures_report(php_vulnerabilities, sql_plaintext_passwords, scanned_files)
    print("Cryptographic Failures Report generated successfully at reports/result_static_cryptographic_failures.txt!\n")
