# detectors/insecure_design_detector.py

import re
from typing import Dict, List, Any
from core.base_detector import BaseDetector
import logging

class InsecureDesignDetector(BaseDetector):
    """
    Detector for identifying insecure design patterns in PHP files,
    such as missing brute-force protection or lack of two-factor authentication mechanisms.
    """

    def __init__(self, config: Dict):
        super().__init__(config)
        self.logger = logging.getLogger(self.__class__.__name__)  # Initialize logger

    def scan(self, input_data: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        """
        Scan PHP files for insecure design issues.

        Args:
            input_data (Dict[str, Dict[str, str]]): Dictionary containing 'php_files' and their contents.

        Returns:
            Dict[str, Any]: Dictionary containing vulnerabilities and scanned_files.
        """
        vulnerabilities = []
        scanned_files = []

        php_files = input_data.get('php_files', {})
        if not php_files:
            self.logger.info("No PHP files to scan.")
        else:
            for php_file, content in php_files.items():
                if php_file.lower().endswith('.php'):
                    if php_file not in scanned_files:
                        scanned_files.append(php_file)
                    self.logger.info(f"Scanning PHP file: {php_file}")
                    vuln = self.analyze_php_file(content, php_file)
                    for v in vuln:
                        v['detector'] = 'InsecureDesignDetector'  # Add detector name
                    vulnerabilities.extend(vuln)
                else:
                    self.logger.warning(f"Skipping non-PHP file: {php_file}")

        return {
            'vulnerabilities': vulnerabilities,
            'scanned_files': scanned_files
        }

    def analyze_php_file(self, content: str, php_file: str) -> List[Dict]:
        """
        Analyze a PHP file for insecure design patterns.

        Args:
            content (str): Content of the PHP file.
            php_file (str): Name of the PHP file.

        Returns:
            List[Dict]: List of detected vulnerabilities.
        """
        vulnerabilities = []

        # Skip files not related to authentication or password handling
        if not self.is_auth_related_file(php_file) or not self.contains_password_keywords(content):
            return vulnerabilities  # Skip if not related to authentication

        # Check for specific insecure design indicators
        vulnerabilities.extend(self.check_insecure_design_indicators(content, php_file))
        return vulnerabilities

    @staticmethod
    def is_auth_related_file(php_file: str) -> bool:
        """
        Determine if the file name suggests it is related to authentication.

        Args:
            php_file (str): Name of the PHP file.

        Returns:
            bool: True if the file is related to authentication, False otherwise.
        """
        return bool(re.search(r'\b(login|auth|signin|sign_in)\b', php_file, re.IGNORECASE))

    @staticmethod
    def contains_password_keywords(content: str) -> bool:
        """
        Check if the file content includes keywords related to passwords.

        Args:
            content (str): Content of the PHP file.

        Returns:
            bool: True if password-related keywords are found, False otherwise.
        """
        return bool(re.search(r'\b(pass|password|passwd)\b', content, re.IGNORECASE))

    def check_insecure_design_indicators(self, content: str, php_file: str) -> List[Dict]:
        """
        Analyze PHP content for insecure design indicators.

        Args:
            content (str): Content of the PHP file.
            php_file (str): Name of the PHP file.

        Returns:
            List[Dict]: List of detected vulnerabilities.
        """
        vulnerabilities = []

        # Check for brute-force protection mechanism
        brute_force_protection_found = bool(
            re.search(r'\b(login_attempts|lockout|rate_limit|sleep|throttle)\b', content, re.IGNORECASE)
        )

        # Check for two-factor authentication indicators
        two_factor_authentication_found = bool(
            re.search(r'\b(two_factor|send_otp|check_2fa|verify_otp|authenticator)\b', content, re.IGNORECASE)
        )

        if not brute_force_protection_found:
            vulnerabilities.append({
                'file': php_file,
                'description': 'Missing brute-force protection mechanism.',
                'impact': 'Vulnerable to brute-force attacks.',
                'recommendation': 'Implement account lockout after multiple failed login attempts or add delay between attempts.'
            })
            self.logger.warning(f"Missing brute-force protection in {php_file}")

        if not two_factor_authentication_found:
            vulnerabilities.append({
                'file': php_file,
                'description': 'Missing two-factor authentication.',
                'impact': 'Accounts are vulnerable to unauthorized access with password alone.',
                'recommendation': 'Add two-factor authentication for stronger security.'
            })
            self.logger.warning(f"Missing two-factor authentication in {php_file}")

        return vulnerabilities
