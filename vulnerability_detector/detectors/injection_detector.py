# detectors/injection_detector.py

import re
from typing import List, Dict, Any
from core.base_detector import BaseDetector
import logging

class InjectionDetector(BaseDetector):
    """
    Detector for identifying Injection vulnerabilities (e.g., XSS) in PHP files.
    """

    def __init__(self, config: Dict):
        super().__init__(config)
        self.logger = logging.getLogger(self.__class__.__name__)  # Initialize logger

    def scan(self, input_data: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        """
        Scan PHP files for injection vulnerabilities.

        Args:
            input_data (Dict[str, Dict[str, str]]): Dictionary containing 'php_files' and 'sql_files' with their contents.

        Returns:
            Dict[str, Any]: Dictionary containing vulnerabilities and scanned_files.
        """
        vulnerabilities = []
        scanned_files = []

        php_files = input_data.get('php_files', {})
        if not php_files:
            self.logger.info("No PHP files to scan for Injection vulnerabilities.")
        else:
            for php_file, content in php_files.items():
                if php_file.lower().endswith('.php'):
                    scanned_files.append(php_file)
                    self.logger.info(f"Scanning PHP file for injection vulnerabilities: {php_file}")
                    try:
                        vuln = self.analyze_php_file(content, php_file)
                        vulnerabilities.extend(vuln)
                    except Exception as e:
                        self.logger.error(f"Error analyzing {php_file}: {e}")
                else:
                    self.logger.debug(f"Skipping non-PHP file: {php_file}")

        return {
            'vulnerabilities': vulnerabilities,
            'scanned_files': scanned_files
        }

    def analyze_php_file(self, content: str, php_file: str) -> List[Dict]:
        """
        Analyze a PHP file for injection vulnerabilities.

        Args:
            content (str): Content of the PHP file.
            php_file (str): Name of the PHP file.

        Returns:
            List[Dict]: List of vulnerabilities found in the PHP file.
        """
        vulnerabilities = []

        # Define patterns to detect potential XSS vulnerabilities
        xss_patterns = [
            re.compile(r"echo\s+\$_(GET|POST|REQUEST)\[.*\];", re.IGNORECASE),
            re.compile(r"print\s+\$_(GET|POST|REQUEST)\[.*\];", re.IGNORECASE),
            re.compile(r"<\?=\s*\$_(GET|POST|REQUEST)\[.*\]\s*\?>", re.IGNORECASE),
            re.compile(r"\$_(GET|POST|REQUEST)\[.*\]", re.IGNORECASE),
        ]

        lines = content.split('\n')
        vulnerable_lines = []

        for i, line in enumerate(lines, start=1):
            self.logger.debug(f"Scanning line {i}: {line.strip()}")
            for pattern in xss_patterns:
                if pattern.search(line):
                    # Check if htmlspecialchars is used in the same line (case-insensitive)
                    if 'htmlspecialchars' not in line.lower():
                        self.logger.debug(f"Vulnerability detected on line {i}")
                        vulnerable_lines.append(f"Line {i}: {line.strip()}")
                        break  # Avoid multiple detections on the same line

        if vulnerable_lines:
            vulnerabilities.append({
                'file': php_file,
                'description': 'Potential XSS vulnerability detected: unfiltered user input is directly output to the page.',
                'impact': 'Allows attackers to inject malicious scripts, leading to session hijacking, defacement, or redirection.',
                'recommendation': 'Sanitize user input by using htmlspecialchars() or a similar function to escape HTML characters.',
                'locations': vulnerable_lines  # Always include 'locations' key
            })
            self.logger.warning(f"Potential XSS vulnerabilities found in {php_file}: {len(vulnerable_lines)} instances.")
        # Do NOT add entries when no vulnerabilities are found to keep the vulnerabilities list clean
        return vulnerabilities
