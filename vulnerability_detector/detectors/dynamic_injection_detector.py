# detectors/dynamic_injection_detector.py

import time
import logging
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoAlertPresentException
from typing import Dict, List, Any
from core.base_detector import BaseDetector
from config.config import LOGIN_URL, REVIEW_URL, ADMIN_URL, APP_USERNAME, APP_PASSWORD
from utils.utils import capture_sensitive_data
from report_generators.dynamic_injection_report import DynamicInjectionReportGenerator

class DynamicInjectionDetector(BaseDetector):
    """
    Detector for performing dynamic injection testing using Selenium WebDriver.
    """

    def __init__(self, config: Dict):
        """
        Initialize the DynamicInjectionDetector with the given configuration.

        Args:
            config (Dict): Configuration dictionary.
        """
        super().__init__(config)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.config = config
        self.driver = None
        self.vulnerabilities = []
        self.page_name = 'Review Page'
        self.captured_data = None
        self.page_source = None

    def scan(self, input_data: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        """
        Perform the dynamic injection test.

        Args:
            input_data (Dict[str, Dict[str, str]]): Unused in this context.

        Returns:
            Dict[str, Any]: Dictionary containing vulnerabilities and scanned_files.
        """
        self.logger.info("Starting dynamic injection test.")
        self.driver = webdriver.Chrome()

        try:
            success = self.login_and_inject_xss()
            if success:
                self.verify_and_export_data()
            else:
                self.logger.warning("XSS injection was not successful.")
        finally:
            self.driver.quit()

        # Prepare the findings to be consistent with other detectors
        findings = {
            'vulnerabilities': self.vulnerabilities,
            'scanned_files': []  # Dynamic testing doesn't involve static files
        }

        # Generate the dynamic report
        report_generator = DynamicInjectionReportGenerator(
            success=success,
            page_name=self.page_name,
            vulnerabilities=self.vulnerabilities,
            captured_data=self.captured_data,
            page_source=self.page_source
        )
        report_generator.generate_report()

        return findings

    def login_and_inject_xss(self) -> bool:
        """
        Logs in to the application and injects an XSS payload into the Review Page form.

        Returns:
            bool: True if the XSS injection was successful, False otherwise.
        """
        try:
            # Step 1: Log in to the application
            self.driver.get(self.config.LOGIN_URL)
            time.sleep(2)
            self.driver.find_element(By.XPATH, '/html/body/div[1]/form/div[1]/input').send_keys(self.config.APP_USERNAME)
            self.driver.find_element(By.XPATH, '/html/body/div[1]/form/div[2]/input').send_keys(self.config.APP_PASSWORD)
            self.driver.find_element(By.XPATH, '/html/body/div[1]/form/input').click()
            time.sleep(3)

            # Step 2: Navigate to the Review Page and inject XSS script
            self.driver.get(self.config.REVIEW_URL)
            time.sleep(2)

            xss_payload = """
                <script>
                alert("XSS Attack! Collecting sensitive data...");
                var cookies = document.cookie;
                console.log("Cookies: " + cookies);
                </script>
            """

            self.driver.find_element(By.XPATH, '/html/body/section[2]/div/form/textarea').send_keys(xss_payload)
            self.driver.find_element(By.XPATH, '/html/body/section[2]/div/form/button').click()
            time.sleep(2)

            # Handle the alert that appears from the XSS payload
            xss_detected = False
            try:
                alert = self.driver.switch_to.alert
                self.logger.info(f"Alert text: {alert.text}")
                alert.accept()  # Close the alert
                time.sleep(1)
                xss_detected = True
            except NoAlertPresentException:
                self.logger.warning("No alert present after XSS injection.")

            # Step 3: Capture any sensitive data and prepare for the report
            self.page_source = self.driver.page_source
            self.captured_data = capture_sensitive_data(self.driver)

            if xss_detected:
                self.vulnerabilities.append({
                    'detector': 'DynamicInjectionDetector',
                    'type': 'XSS',
                    'description': 'XSS vulnerability in form submission.',
                    'impact': 'Allows script execution in user session.',
                    'recommendation': 'Sanitize user input using HTML encoding.',
                    'file': 'Review Page',
                    'location': 'Form submission on the Review Page'
                })
                self.logger.info("XSS vulnerability detected.")
                return True  # Vulnerability found
            else:
                self.logger.info("No XSS vulnerability detected.")
                return False  # No vulnerability found
        except Exception as e:
            self.logger.error(f"Error during XSS injection: {e}")
            return False

    def verify_and_export_data(self):
        """
        Verifies data persistence by accessing the Adminer database and exports the data.
        """
        try:
            # Step 4: Verify data in the Adminer database
            self.driver.get(self.config.ADMIN_URL)
            time.sleep(2)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form/table/tbody/tr[3]/td/input').send_keys("krossale")
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form/table/tbody/tr[4]/td/input').send_keys("webove aplikace")
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form/p/input').click()
            time.sleep(2)

            # Navigate to the target table and check data
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form/table/tbody/tr[2]/th/a').click()
            time.sleep(1)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form/div[1]/table/tbody/tr[2]/th/a').click()
            time.sleep(1)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/p[2]/a[1]').click()

            # Step 5: Export data
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form[2]/div[2]/div/fieldset[4]/legend/a').click()
            time.sleep(1)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form[2]/div[2]/div/fieldset[4]/div/select[1]').click()
            time.sleep(1)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form[2]/div[2]/div/fieldset[4]/div/select[1]/option[2]').click()
            time.sleep(1)
            self.driver.find_element(By.XPATH, '/html/body/div[2]/form[2]/div[2]/div/fieldset[4]/div/input').click()

            self.logger.info("Database entry verified and exported.")
        except Exception as e:
            self.logger.error(f"Error during database verification: {e}")
