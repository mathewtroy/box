# detectors/cryptographic_failures_detector.py

import re
from typing import List, Dict, Any, Union
from core.base_detector import BaseDetector
import logging

class CryptographicFailuresDetector(BaseDetector):
    """
    Detector for identifying cryptographic failures in PHP and SQL files.
    """

    def __init__(self, config: Dict):
        super().__init__(config)
        self.logger = logging.getLogger(self.__class__.__name__)

    def scan(self, input_data: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        """
        Scan PHP and SQL files for cryptographic vulnerabilities.

        Args:
            input_data (Dict[str, Dict[str, str]]): Dictionary containing 'php_files' and 'sql_files' with their contents.

        Returns:
            Dict[str, Any]: Dictionary containing vulnerabilities, scanned_files, and plaintext_passwords.
        """
        vulnerabilities = []
        scanned_files = []
        plaintext_passwords = {}

        # Scan PHP files
        php_files = input_data.get('php_files', {})
        if not php_files:
            self.logger.info("No PHP files to scan.")
        else:
            for php_file, content in php_files.items():
                scanned_files.append(php_file)
                if not php_file.lower().endswith('.php'):
                    vulnerabilities.append({
                        'file': php_file,
                        'description': 'Non-PHP file detected in PHP directory.',
                        'impact': 'None',
                        'recommendation': 'Ensure only PHP files are placed in the vulnerable directory.'
                    })
                    self.logger.warning(f"Non-PHP file found: {php_file}")
                    continue

                self.logger.info(f"Scanning PHP file: {php_file}")
                vuln = self.analyze_php_file(content, php_file)
                vulnerabilities.extend(vuln)

        # Scan SQL files
        sql_files = input_data.get('sql_files', {})
        if not sql_files:
            self.logger.info("No SQL files to scan.")
        else:
            for sql_file, content in sql_files.items():
                scanned_files.append(sql_file)
                self.logger.info(f"Scanning SQL file: {sql_file}")
                vuln = self.analyze_sql_file(content, sql_file)
                vulnerabilities.extend(vuln)

        return {
            'vulnerabilities': vulnerabilities,
            'scanned_files': scanned_files,
            'plaintext_passwords': self.collect_plaintext_passwords(input_data.get('sql_files', {}))
        }

    def analyze_php_file(self, content: str, php_file: str) -> List[Dict]:
        """
        Analyze a PHP file for cryptographic vulnerabilities.

        Args:
            content (str): Content of the PHP file.
            php_file (str): Name of the PHP file.

        Returns:
            List[Dict]: List of vulnerabilities found in the PHP file.
        """
        vulnerabilities = []
        contains_password_input = re.search(r'<input\s+[^>]*type=["\']password["\']', content, re.IGNORECASE)

        if contains_password_input:
            if 'register' in php_file.lower():
                password_hash_present = re.search(r"password_hash\s*\(", content, re.IGNORECASE) is not None

                if not password_hash_present:
                    vulnerabilities.append({
                        'file': php_file,
                        'description': 'Passwords are stored without using password_hash during registration.',
                        'impact': 'Passwords might be stored in plain text, making them vulnerable to compromise.',
                        'recommendation': 'Use password_hash() function to securely hash passwords before storing them in the database.'
                    })
                    self.logger.warning(f"Detected missing password_hash in {php_file}")
            elif 'login' in php_file.lower():
                password_verify_present = re.search(r"password_verify\s*\(", content, re.IGNORECASE) is not None
                password_compare_pattern = re.compile(r"if\s*\(\s*\$pass\s*==\s*\$row\['password'\]\s*\)", re.IGNORECASE)

                if password_compare_pattern.search(content) and not password_verify_present:
                    vulnerabilities.append({
                        'file': php_file,
                        'description': 'Passwords are compared in plain text without using password_verify during authentication.',
                        'impact': 'Sensitive user passwords are vulnerable to compromise in case of a data breach.',
                        'recommendation': 'Use password_verify() function to verify hashed passwords during user authentication.'
                    })
                    self.logger.warning(f"Detected plaintext password comparison in {php_file}")
            else:
                password_hash_present = re.search(r"password_hash\s*\(", content, re.IGNORECASE) is not None
                password_verify_present = re.search(r"password_verify\s*\(", content, re.IGNORECASE) is not None

                if not password_hash_present:
                    vulnerabilities.append({
                        'file': php_file,
                        'description': 'Passwords are stored without using password_hash.',
                        'impact': 'Passwords might be stored in plain text, making them vulnerable to compromise.',
                        'recommendation': 'Use password_hash() function to securely hash passwords before storing them in the database.'
                    })
                    self.logger.warning(f"Detected missing password_hash in {php_file}")

                if not password_verify_present:
                    vulnerabilities.append({
                        'file': php_file,
                        'description': 'Passwords are compared in plain text without using password_verify.',
                        'impact': 'Sensitive user passwords are vulnerable to compromise in case of a data breach.',
                        'recommendation': 'Use password_verify() function to verify hashed passwords during user authentication.'
                    })
                    self.logger.warning(f"Detected missing password_verify in {php_file}")
        else:
            self.logger.info(f"No password-related vulnerabilities detected in {php_file}.")

        return vulnerabilities

    def analyze_sql_file(self, content: str, sql_file: str) -> List[Dict]:
        """
        Analyze an SQL file for plaintext password storage issues.

        Args:
            content (str): Content of the SQL file.
            sql_file (str): Name of the SQL file.

        Returns:
            List[Dict]: List of vulnerabilities found in the SQL file.
        """
        vulnerabilities = []
        insert_pattern = re.compile(
            r"INSERT\s+INTO\s+`users`\s+\((.*?)\)\s+VALUES\s*\((.*?)\);",
            re.IGNORECASE | re.DOTALL
        )
        matches = insert_pattern.findall(content)
        records_with_plaintext = []

        if matches:
            for columns, values in matches:
                columns = [col.strip(' `') for col in columns.split(',')]
                records = re.findall(r'\((.*?)\)', values)
                for record in records:
                    values_list = [val.strip(" '") for val in record.split(',')]
                    user_record = dict(zip(columns, values_list))
                    password = user_record.get('password', '')

                    if not (len(password) == 60 and (password.startswith('$2y$') or password.startswith('$2a$'))):
                        records_with_plaintext.append(user_record)

        if records_with_plaintext:
            vulnerabilities.append({
                'file': sql_file,
                'description': 'Passwords are stored in plain text without hashing.',
                'impact': 'Passwords are vulnerable to being compromised if the database is breached.',
                'recommendation': 'Use password_hash() to store hashed passwords.'
            })
            self.logger.warning(f"Detected plaintext passwords in {sql_file}")
        elif matches:
            self.logger.info(f"No plaintext passwords found in {sql_file}")

        return vulnerabilities

    def collect_plaintext_passwords(self, sql_files: Dict[str, str]) -> Dict[str, Union[str, List[Dict]]]:
        """
        Collect plaintext password records from SQL files.

        Args:
            sql_files (Dict[str, str]): Dictionary of SQL file contents.

        Returns:
            Dict[str, Union[str, List[Dict]]]: Mapping of SQL files to plaintext password records or a message.
        """
        plaintext_passwords = {}

        for sql_file, content in sql_files.items():
            insert_pattern = re.compile(
                r"INSERT\s+INTO\s+`users`\s+\((.*?)\)\s+VALUES\s*\((.*?)\);",
                re.IGNORECASE | re.DOTALL
            )
            matches = insert_pattern.findall(content)
            records_found = False
            records = []

            if matches:
                for columns, values in matches:
                    columns = [col.strip(' `') for col in columns.split(',')]
                    record_matches = re.findall(r'\((.*?)\)', values)
                    for record in record_matches:
                        values_list = [val.strip(" '") for val in record.split(',')]
                        user_record = dict(zip(columns, values_list))
                        password = user_record.get('password', '')

                        if not (len(password) == 60 and (password.startswith('$2y$') or password.startswith('$2a$'))):
                            records.append(user_record)
                            records_found = True

            if records_found:
                plaintext_passwords[sql_file] = records
            else:
                plaintext_passwords[sql_file] = "No plaintext passwords found."

        return plaintext_passwords
