# detectors/ssrf_detector.py

import re
from typing import Dict, List, Any
from core.base_detector import BaseDetector
import logging


class SSRFDetector(BaseDetector):
    """
    Detector for identifying potential SSRF vulnerabilities in PHP files.
    """

    def __init__(self, config: Dict):
        """
        Initialize the SSRFDetector with the given configuration.

        Args:
            config (Dict): Configuration dictionary.
        """
        super().__init__(config)
        self.logger = logging.getLogger(self.__class__.__name__)  # Initialize logger

    def scan(self, input_data: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        """
        Scan PHP files for potential SSRF vulnerabilities.

        Args:
            input_data (Dict[str, Dict[str, str]]): Dictionary containing 'php_files' and their contents.

        Returns:
            Dict[str, Any]: Dictionary containing vulnerabilities and scanned_files.
        """
        vulnerabilities = []
        scanned_files = []

        php_files = input_data.get('php_files', {})
        if not php_files:
            self.logger.info("No PHP files to scan.")
        else:
            for php_file, content in php_files.items():
                if php_file.lower().endswith('.php'):
                    scanned_files.append(php_file)
                    self.logger.info(f"Scanning PHP file: {php_file}")
                    vuln = self.analyze_php_file(content, php_file)
                    for v in vuln:
                        v['detector'] = 'SSRFDetector'  # Add detector name
                    vulnerabilities.extend(vuln)
                else:
                    self.logger.warning(f"Skipping non-PHP file: {php_file}")

        return {
            'vulnerabilities': vulnerabilities,
            'scanned_files': scanned_files
        }

    def analyze_php_file(self, content: str, php_file: str) -> List[Dict]:
        """
        Analyze a PHP file for SSRF vulnerabilities.

        Args:
            content (str): Content of the PHP file.
            php_file (str): Name of the PHP file.

        Returns:
            List[Dict]: List of detected vulnerabilities.
        """
        vulnerabilities = self.find_ssrf_patterns(content, php_file)
        return vulnerabilities

    def find_ssrf_patterns(self, content: str, php_file: str) -> List[Dict]:
        """
        Identify potential SSRF patterns in the PHP content.

        Args:
            content (str): The content of the PHP file.
            php_file (str): The name of the PHP file being analyzed.

        Returns:
            List[Dict]: A list of SSRF vulnerabilities found in the file.
        """
        vulnerabilities = []
        ssrf_patterns = [
            r'\b(file_get_contents|curl_exec|curl_init|fopen|fsockopen|readfile)\b',
            # Functions often exploited for SSRF
            r'["\'](http:\/\/|https:\/\/|ftp:\/\/|file:\/\/)[^"\']*["\']'  # Strings containing URLs
        ]

        for pattern in ssrf_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                vulnerabilities.append({
                    'file': php_file,
                    'description': 'Potential SSRF vulnerability due to unvalidated external resource fetching.',
                    'impact': 'May allow attackers to access internal services or execute malicious requests.',
                    'recommendation': (
                        'Validate and sanitize all user-supplied URLs. Use a positive allowlist for permitted domains. '
                        'Avoid using raw user input in requests to remote resources.'
                    )
                })
                self.logger.warning(f"Potential SSRF vulnerability found in {php_file}")
                break  # Exit loop once a vulnerability is detected for this file

        return vulnerabilities
